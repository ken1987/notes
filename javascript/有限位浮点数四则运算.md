#有限位浮点数四则运算

项目中遇到js浮点运算导致的精度丢失问题，网上大多通过乘法补位成为整数后再进行运算，但是今天项目中发现乘法也会丢失精度，例如4481.9x100，所以通过之前的方法不能有效的解决这个问题，于是考虑通过操作字符串的方式来解决，通过几次修改有以下版本。

```javascript
/**
 * 有限位浮点数四则运算
 * 浮点数过大时，会导致数值转换int时或后续计算时位数过大溢出
 * @example
 * // calculator('.1+0.2');
 * // calculator('4481.9 * 100');
 * // calculator('.1 / 20');
 */
var calculator = (function() {
    /**
     * 获取小数位长度
     * @param  {string}  num   字符串型数值
     * @return {number}  小数位长度
     */
    var getDigit = function(num) {
        num = num.split(".")[1];
        return num ? num.length : 0;
    };

    /**
     * 转换成整数
     * @param  {string} num  字符串型数值
     * @param  {number} digit   位数
     * @return {string} 字符串型数值
     */
    var parser2Int = function(num, digit) {
        return num.replace(/\.(.*)/, function(str, num) {
            var len = num.length;
            return len ? num * Math.pow(10, digit - len) : '';
        });
    };

    /**
     * 计算函数
     * @param  {string} expression 简单的四则运算表达式
     * @return {number} 运算结果
     */
    return function(expression) {
        var result = NaN;
        expression.replace(
            /([\d\.]+)\s?([+\-\*\/])\s?([\d\.]+)/, //只匹配一次
            /**
             * 通过正则分析语法
             * @param  {string} str         匹配的字符串
             * @param  {string} num1        被操作数
             * @param  {string} operator    操作符
             * @param  {string} num2        操作数
             */
            function(str, num1, operator, num2) {
                if (!isNaN(num1) && !isNaN(num2) && operator) {
                    var d1 = getDigit(num1);
                    var d2 = getDigit(num2);

                    //加法和减法
                    if (operator == '+' || operator == '-') {
                        d1 = d1 > d2 ? d1 : d2; //最大的小数位
                        num1 = parser2Int(num1, d1);
                        num2 = parser2Int(num2, d1);

                        //避免加号被当作是字符串连接符，因此通过转换成减法隐式的类型转换
                        if (operator == '+') {
                            num2 = -num2;
                        }
                        result = (num1 - num2) / Math.pow(10, d1);
                    } else {
                        num1 = parser2Int(num1, d1);
                        num2 = parser2Int(num2, d2);
                        d1 = d1 + d2; //需要被除回来的
                        if (operator == '*') {
                            result = num1 * num2 / Math.pow(10, d1);
                        } else {
                            result = num2 ? num1 / (num2 * Math.pow(10, d1)) : NaN; //除数不能为0
                        }
                    }
                }
            });
        return result;
    };
}());
```
##相关参考
* [dtrebbien/BigDecimal.js](https://github.com/dtrebbien/BigDecimal.js)
* [JS计算0.1+0.2≠0.3，求解法？](https://www.zhihu.com/question/24415787)
* [代码之谜（四）- 浮点数（从惊讶到思考）](http://justjavac.com/codepuzzle/2012/11/02/codepuzzle-float-from-surprised-to-ponder.html)
